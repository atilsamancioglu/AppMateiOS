// Generated by Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
#ifndef APPMATE_SWIFT_H
#define APPMATE_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="appmate",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif


@class NSString;

SWIFT_CLASS("_TtC7appmate23ConsumePurchaseResponse")
@interface ConsumePurchaseResponse : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class UserRelation;

SWIFT_CLASS("_TtC7appmate26CreateUserRelationResponse")
@interface CreateUserRelationResponse : NSObject
@property (nonatomic, readonly, strong) UserRelation * _Nullable data;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC7appmate26DeleteUserRelationResponse")
@interface DeleteUserRelationResponse : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC7appmate18DescriptionDecoder")
@interface DescriptionDecoder : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC7appmate11Entitlement")
@interface Entitlement : NSObject
@end


SWIFT_CLASS("_TtC7appmate9FreeTrial")
@interface FreeTrial : NSObject
@end


/// An object which is used for custom error messages.
SWIFT_CLASS("_TtC7appmate12GenericError")
@interface GenericError : NSObject
@property (nonatomic, copy) NSString * _Null_unspecified message;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithMessage:(NSString * _Nonnull)message OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end


SWIFT_CLASS("_TtC7appmate17IntroductoryOffer")
@interface IntroductoryOffer : NSObject
@end

@class SubscriptionDuration;
@class ProductOffer;

/// In-app purchase product such as consumables, non-consumables or subscriptions.
/// In order to use in-app purchases, first you must create products.
/// There are 3 different product types:
/// <ul>
///   <li>
///     Consumables
///   </li>
///   <li>
///     Non-consumables
///   </li>
///   <li>
///     Subscriptions
///     <ul>
///       <li>
///         Auto renewable subscriptions
///       </li>
///       <li>
///         Non-renewable subscriptions.
///       </li>
///     </ul>
///   </li>
/// </ul>
SWIFT_CLASS("_TtC7appmate7Product")
@interface Product : NSObject
@property (nonatomic, copy) NSString * _Nullable productId;
@property (nonatomic, copy) NSString * _Nullable uspAppId;
@property (nonatomic, copy) NSString * _Nullable defaultLanguage;
@property (nonatomic, copy) NSString * _Nullable purchaseType;
@property (nonatomic, copy) NSString * _Nullable status;
@property (nonatomic, copy) NSArray<NSString *> * _Nullable entitlements;
@property (nonatomic, copy) NSString * _Nullable subsPeriod;
@property (nonatomic, copy) NSString * _Nullable subGroupId;
@property (nonatomic, copy) NSString * _Nullable subGroupName;
@property (nonatomic, copy) NSString * _Nullable promotionId;
@property (nonatomic, copy) NSString * _Nullable trialPeriod;
@property (nonatomic, copy) NSString * _Nullable introductoryPeriod;
@property (nonatomic, copy) NSString * _Nullable gracePeriod;
@property (nonatomic, copy) NSString * _Nullable appleSyncStatus;
@property (nonatomic, copy) NSString * _Nullable applePrice;
@property (nonatomic, copy) NSString * _Nullable appleCurrency;
@property (nonatomic, copy) NSString * _Nullable appleSubsType;
@property (nonatomic, copy) NSString * _Nullable appleSubsIntStartDate;
@property (nonatomic, copy) NSString * _Nullable appleSubsIntEndDate;
@property (nonatomic, copy) NSString * _Nullable appleSubsIntOfferType;
@property (nonatomic, copy) NSString * _Nullable appleSubsIntDuration;
@property (nonatomic, copy) NSString * _Nullable appleSubsIntFreeTrialDuration;
@property (nonatomic, copy) NSString * _Nullable appleSubsIntFreeTrialStartDate;
@property (nonatomic, copy) NSString * _Nullable appleSubsIntFreeTrialEndDate;
@property (nonatomic, strong) SubscriptionDuration * _Nullable subscriptionDuration;
@property (nonatomic, strong) ProductOffer * _Nullable productOffer;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC7appmate12ProductOffer")
@interface ProductOffer : NSObject
@end

@class PurchaseInfo;
@class PurchaseResultInfo;
enum PurchaseCode : NSInteger;
@class UserEvent;

/// A class used for creating and controlling in-app purchases.
/// PurchaseClient is the main class of appmate. Appmate helps developers to manage in-application purchases easily. Thanks to appmate, it is much easier to create and consume IAP products, manage purchases, user relations and vice versa. For further information you can view the detailed <a href="http://www.appmate.tech/docs/sdk/ios">documentation</a>.
SWIFT_CLASS("_TtC7appmate14PurchaseClient")
@interface PurchaseClient : NSObject
/// A shared object for PurchaseClient class.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) PurchaseClient * _Nonnull shared;)
+ (PurchaseClient * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
+ (void)setShared:(PurchaseClient * _Nonnull)value;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// This method can be used to fetch non-synched products from appmate. While it is true, non-synched products will also be able to fetched as a response; otherwise, only the products successfully synched with Apple Store can be fetched. The default parameter is false.
/// \param isActive Used to activate the sandbox. While it is true, non-synched products will also be fetched.
///
- (void)setSandboxActive:(BOOL)isActive;
/// Sets  appmate apiKey.
/// Api key can be retrieved from appmate portal via navigating to application page.
/// \param apiKey Unique identifier for using appmate services.
///
- (void)setApiKey:(NSString * _Nonnull)apiKey;
- (void)setRuntimeEnvironment:(NSString * _Nonnull)environment;
/// Modifies  device user id. The default user id is set by device automatically.
/// It’s an optional parameter that uniquely identifies your users within your application. You should set it only if you have a membership system for your app.
/// You could specify your own user identifiers with setUserId method later in your app lifecycle.
/// This method requires a userId as a type of String and should be a unique value. It’s necessary to fetch products and make purchase.
/// \param userId Device user id information.
///
- (void)setUserId:(NSString * _Nonnull)userId;
/// Returns device user id.
/// User id can be retrieved  from appmate SDK regardless of you set a userId or a random userId is created.
///
/// returns:
/// The user id will be returned as String.
- (NSString * _Nonnull)getUserId SWIFT_WARN_UNUSED_RESULT;
/// Modifies  OneSignal identification.
/// If users of Appmate use One Signal services to receive push notifications, they should set their One Signal ids via setOneSignalId.
/// So, they will be able to receive push notifications relating to appmate.
/// \param oneSignalId OneSignal id information.
///
- (void)setOneSignalId:(NSString * _Nonnull)oneSignalId;
/// Modifies  AppsFlyer identification.
/// If users of Appmate has integration of the AppsFlyer, they can set the AppsFlyerId value via this method
/// \param appsFlyerId the identification of the  AppsFlyer app configuration
///
- (void)setAppsFlyerId:(NSString * _Nonnull)appsFlyerId;
/// set the Identifier for Advertisers assigned by Apple to a user’s device.
/// If users of Appmate has integration of the AppsFlyer, they can set the AppsFlyerId value via this method
/// \param IDFA the Identifier for Advertisers
///
- (void)setIDFA:(NSString * _Nonnull)IDFA;
/// allows user to add a set of  dynamic User Specific Attributes.
/// \param userAttribute any set of information that the user needs to add for example (userName, userEmail etc …)
///
- (void)setUserAttributes:(NSDictionary<NSString *, id> * _Nonnull)userAttribute;
/// Fetches all the products created on appmate server. If sandbox parameter value is false, non-synched products will not be fetched.
/// If a previous successful fetch exists in last 10 minutes, it fetches the products from local cache.
/// So you will be able to get the response faster than getting directly from the network. Otherwise, it will launch a network request.
/// If you add a new product and want to see it in your app for testing purposes, you can delete your app’s cache.
/// The products will be fetched from the network the next time you open your app.
/// \param completion Callbacks Product array and GenericError in case of failure.
///
- (void)getProductsWithCompletion:(void (^ _Nonnull)(NSArray<Product *> * _Nullable, GenericError * _Nullable))completion;
/// Fetches the filtered products with specified type from appmate server. If sandbox parameter value is false, non-synched products will not be fetched.
/// If a previous successful fetch exists in last 10 minutes, it fetches the products from local cache.
/// So you will be able to get the response faster than getting directly from the network. Otherwise, it will launch a network request.
/// If you add a new product and want to see it in your app for testing purposes, you can delete your app’s cache.
/// The products will be fetched from the network the next time you open your app.
/// \param type Type of products as String. It must be typed as “0” for consumables, “1” for non-consumables and “2” for subscriptions.
///
/// \param completion Callbacks Product array and GenericError in case of failure.
///
- (void)getProductsWithType:(NSString * _Nonnull)type completion:(void (^ _Nonnull)(NSArray<Product *> * _Nullable, GenericError * _Nullable))completion;
/// Fetches the filtered products with specified id list from appmate server. If sandbox parameter value is false, non-synched products will not be fetched.
/// If a previous successful fetch exists in last 10 minutes, it fetches the products from local cache.
/// So you will be able to get the response faster than getting directly from the network. Otherwise, it will launch a network request.
/// If you add a new product and want to see it in your app for testing purposes, you can delete your app’s cache.
/// The products will be fetched from the network the next time you open your app.
/// \param idList List of desired product ids as String array.
///
/// \param completion Callbacks Product array and GenericError in case of failure.
///
- (void)getProductsWithIdList:(NSArray<NSString *> * _Nonnull)idList completion:(void (^ _Nonnull)(NSArray<Product *> * _Nullable, GenericError * _Nullable))completion;
/// Fetches all the purchases made so far from appmate server.
/// If a previous successful fetch exists in last 10 minutes, it fetches the products from local cache.
/// So you will be able to get the response faster than getting directly from the network. Otherwise, it will launch a network request.
/// By calling getAllPurchases method, you can get the list of purchases made so far.
/// Purchases which are made before/without appmate will still be returned.
/// \param completion Callbacks PurchaseInfo array and GenericError in case of failure.
///
- (void)getAllPurchasesWithCompletion:(void (^ _Nonnull)(NSArray<PurchaseInfo *> * _Nullable, GenericError * _Nullable))completion;
/// Fetches all the purchases made so far from appmate server.
/// If a previous successful fetch exists in last 10 minutes, it fetches the products from local cache.
/// So you will be able to get the response faster than getting directly from the network. Otherwise, it will launch a network request.
/// By calling getCurrentPurchases method, you can get the list of purchases filtered by specific rules. These filtering rules are;
/// <ul>
///   <li>
///     Purchased but not consumed consumable products.
///   </li>
///   <li>
///     Non-consumable products.
///   </li>
///   <li>
///     Ongoing subscription products.
///   </li>
/// </ul>
/// Purchases which are made before/without appmate will still be returned if they match these rules.
/// \param completion Callbacks PurchaseInfo array and GenericError in case of failure.
///
- (void)getCurrentPurchasesWithCompletion:(void (^ _Nonnull)(NSArray<PurchaseInfo *> * _Nullable, GenericError * _Nullable))completion;
/// Launches a new purchase transaction using Apple interface.
/// When you want to make a purchase transaction, just pass the Product object parameter to the method, then appmate will communicate with AppStore and handle Apple purchase process.
/// \param with product Provide the Product object you want to purchase.
///
/// \param completion Callbacks PurchaseResultInfo and PurchaseCode in case of failure. If PurchaseResultInfo responds as nil, check PurchaseCode for failure info.
///
- (void)makePurchaseWith:(Product * _Nonnull)product completion:(void (^ _Nonnull)(PurchaseResultInfo * _Nullable, enum PurchaseCode))completion;
/// Consume the purchased product specified with purchaseToken.
/// Once purchase is completed, as a part of purchase process you need to deliver a content with granting entitlement as a result of the user’s purchase.
/// For one-time consumable product, you need to call consume method of the SDK to indicate that your app has granted entitlement to the user.
/// With consumption of the one-time consumable product, the product can be purchased again.
/// After consumption, the product will vanish in current purchases but will still exist in purchase history.
/// \param purchaseToken Token created after a purchase. It can be found inside PurchaseInfo object.
///
/// \param completion Callbacks ConsumePurchaseInfo and GenericError in case of failure.
///
- (void)consumePurchaseWithPurchaseToken:(NSString * _Nonnull)purchaseToken completion:(void (^ _Nonnull)(ConsumePurchaseResponse * _Nullable, GenericError * _Nullable))completion;
/// Consume a list of purchased product specified with purchaseToken list.
/// Once purchase is completed, as a part of purchase process you need to deliver a content with granting entitlement as a result of the user’s purchase.
/// For one-time consumable product, you need to call consume method of the SDK to indicate that your app has granted entitlement to the user.
/// With consumption of the one-time consumable product, the product can be purchased again.
/// After consumption, the product will vanish in current purchases but will still exist in purchase history.
/// \param purchaseTokens Tokens as String array created after a purchase. It can be found inside PurchaseInfo object.
///
/// \param completion Callbacks boolean and GenericError in case of failure.
///
- (void)consumePurchasesWithPurchaseTokens:(NSArray<NSString *> * _Nonnull)purchaseTokens completion:(void (^ _Nonnull)(ConsumePurchaseResponse * _Nullable, GenericError * _Nullable))completion;
/// Restores all the previous purchases of current user.
/// If user has purchases from previous installations of the application, it is possible to restore them by using this method.
/// Apple obliges developers to add a restore button in their applications.
/// \param completion Callbacks PurchaseInfo array and GenericError in case of failure.
///
- (void)restorePurchasesWithCompletion:(void (^ _Nonnull)(NSArray<PurchaseInfo *> * _Nullable, GenericError * _Nullable))completion;
/// Navigates to Subscriptions page of the device.
/// Apple does not allow developer to end subscriptions directly; instead, directs to the Subscriptions page of the device.
- (void)unsubscribe;
/// Checks whether a product is actively purchased or not.
/// With calling [isProductPurchased] method of the SDK you can check whether a product is purchased or not.
/// Once you query a product with productId, a boolean response comes back.
/// True means that the product is purchased. After consumption, it will respond a false value.
/// These are accepted as purchased:
/// <ul>
///   <li>
///     Purchased but not consumed consumable products.
///   </li>
///   <li>
///     Non-consumable products.
///   </li>
///   <li>
///     Ongoing subscription products.
///   </li>
/// </ul>
/// \param productId Id of the product to be checked.
///
/// \param completion Callbacks Bool and GenericError in case of failure.
///
- (void)isProductPurchasedWithProductId:(NSString * _Nonnull)productId completion:(void (^ _Nonnull)(BOOL, GenericError * _Nullable))completion;
/// Creates a relation between current user and another user.
/// This method allows developers to establish a connection between users. Thanks to this relation, sub-user will also own all the purchases  master user have made.
/// For example, you have a user who has two devices and he/she wants to use your app with both of them.
/// If your user has some purchases that made with the first userId, also second userId will be able to see this products as purchased.
/// Whenever there is a change in a user’s entitlement to products within your app, the second device user also will be able to get this updates.
/// It’s easy to use this feature with appmate only by establishing relationships between the users.
/// \param with masterUserId Id of the user has the purchases of his/her own. User id can be retrieved via <em>getUserId</em> method.
///
/// \param completion Callbacks CreateUserRelationResponse and GenericError in case of failure.
///
- (void)createUserIdRelationWith:(NSString * _Nonnull)masterUserId completion:(void (^ _Nonnull)(CreateUserRelationResponse * _Nullable, GenericError * _Nullable))completion;
/// Removes all the existing relations of a master.
/// If you want to delete all the relationships related to the masterUserId, you can use deleteMasterUserIdRelation method by giving masterUserId as a parameter.
/// \param for masterUserId Id of the user has the purchases of his/her own. User id can be retrieved via <em>getUserId</em> method.
///
/// \param completion Callbacks DeleteUserRelationResponse and GenericError in case of failure.
///
- (void)deleteMasterUserIdRelationFor:(NSString * _Nonnull)masterUserId completion:(void (^ _Nonnull)(DeleteUserRelationResponse * _Nullable, GenericError * _Nullable))completion;
/// Removes the existing relation of a sub-user.
/// It’s also possible to delete a relationship between the users.
/// By giving subUserId as a parameter, you can use deleteSubUserIdRelation method and delete a relationship between subUserId and its master.
/// \param for subUserId Id of the user has the purchases of another user. User id can be retrieved via <em>getUserId</em> method.
///
/// \param completion Callbacks DeleteUserRelationResponse and GenericError in case of failure.
///
- (void)deleteSubUserIdRelationFor:(NSString * _Nonnull)subUserId completion:(void (^ _Nonnull)(DeleteUserRelationResponse * _Nullable, GenericError * _Nullable))completion;
/// Fetches all the entitlements created on appmate server.
/// If a previous successful fetch exists in last 10 minutes, it fetches the entitlements from local cache.
/// So you will be able to get the response faster than getting directly from the network. Otherwise, it will launch a network request.
/// \param completion Callbacks entitlements array and GenericError in case of failure.
///
- (void)getEntitlementsWithCompletion:(void (^ _Nonnull)(NSArray<NSString *> * _Nullable, GenericError * _Nullable))completion;
/// Use this to track a specific features and purposes on Appmate dashboard.
/// \param Event UserEvent to specify the type of the event you want to log
/// <ul>
///   <li>
///     AppLaunch: specifying that the user lunched the app
///   </li>
///   <li>
///     ViewProduct: when the user viewing a specific product
///   </li>
///   <li>
///     PurchaseProduct: when the user purchase a specific product
///   </li>
/// </ul>
///
/// \param completion true if the event saved successfully or get the error msg if the result is false
///
- (void)saveAppUserEventsWithEvent:(UserEvent * _Nonnull)event completion:(void (^ _Nullable)(BOOL, GenericError * _Nullable))completion;
@end

/// Enumeration for all possible purchase transaction results.
typedef SWIFT_ENUM(NSInteger, PurchaseCode, open) {
  PurchaseCodeSuccess = 0,
  PurchaseCodeUnknown = -1,
  PurchaseCodeClientInvalid = 1,
  PurchaseCodePaymentCancelled = 2,
  PurchaseCodePaymentInvalid = 3,
  PurchaseCodePaymentNotAllowed = 4,
  PurchaseCodeStoreProductNotAvailable = 5,
  PurchaseCodeCloudServicePermissionDenied = 6,
  PurchaseCodeCloudServiceNetworkConnectionFailed = 7,
  PurchaseCodeCloudServiceRevoked = 8,
  PurchaseCodePrivacyAcknowledgementRequired = 9,
  PurchaseCodeUnauthorizedRequestData = 10,
  PurchaseCodeInvalidOfferIdentifier = 11,
  PurchaseCodeInvalidSignature = 12,
  PurchaseCodeMissingOfferParams = 13,
  PurchaseCodeInvalidOfferPrice = 14,
  PurchaseCodeOverlayCancelled = 15,
  PurchaseCodeOverlayInvalidConfiguration = 16,
  PurchaseCodeOverlayTimeout = 17,
  PurchaseCodeIneligibleForOffer = 18,
  PurchaseCodeUnsupportedPlatform = 19,
  PurchaseCodeOverlayPresentedInBackgroundScene = 20,
};
static NSString * _Nonnull const PurchaseCodeDomain = @"appmate.PurchaseCode";

@class SubscriptionPriceChange;

/// An object which keeps all information about a purchase.
/// After a purchase transaction, all the information created is kept in PurchaseInfo objects.
SWIFT_CLASS("_TtC7appmate12PurchaseInfo")
@interface PurchaseInfo : NSObject
@property (nonatomic, copy) NSString * _Nonnull userId;
@property (nonatomic, copy) NSString * _Nonnull uspAppId;
@property (nonatomic, copy) NSString * _Nonnull productId;
@property (nonatomic, copy) NSString * _Nonnull orderId;
@property (nonatomic, copy) NSString * _Nonnull purchaseTime;
@property (nonatomic) NSInteger purchaseStatus;
@property (nonatomic, copy) NSString * _Nonnull purchaseToken;
@property (nonatomic) BOOL autoRenew;
@property (nonatomic, copy) NSString * _Nonnull developerPayload;
@property (nonatomic, copy) NSString * _Nonnull platform;
@property (nonatomic) BOOL sandbox;
@property (nonatomic, copy) NSString * _Nonnull purchaseType;
@property (nonatomic) NSInteger consumed;
@property (nonatomic, copy) NSString * _Nonnull country;
@property (nonatomic, copy) NSString * _Nonnull currency;
@property (nonatomic, copy) NSString * _Nonnull price;
@property (nonatomic, copy) NSString * _Nullable subGroupId;
@property (nonatomic, copy) NSString * _Nullable expireTime;
@property (nonatomic, copy) NSString * _Nullable lastOrderId;
@property (nonatomic, copy) NSString * _Nullable introductoryPrice;
@property (nonatomic, copy) NSString * _Nullable renewPrice;
@property (nonatomic, copy) NSString * _Nullable graceExpireTime;
@property (nonatomic, copy) NSString * _Nullable nextRenewTime;
@property (nonatomic, strong) SubscriptionPriceChange * _Nullable priceChange;
@property (nonatomic, copy) NSString * _Nullable autoResumeTime;
@property (nonatomic, copy) NSString * _Nullable linkedPurchasedToken;
@property (nonatomic, copy) NSString * _Nullable receiptData;
@property (nonatomic, copy) NSString * _Nullable trialConversionTime;
@property (nonatomic, copy) NSString * _Nullable createDate;
@property (nonatomic, copy) NSString * _Nullable updateDate;
@property (nonatomic, copy) NSDictionary<NSString *, NSNumber *> * _Nonnull reportingPrices;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Result info of a purchase transaction such as success or failure.
SWIFT_CLASS("_TtC7appmate18PurchaseResultInfo")
@interface PurchaseResultInfo : NSObject
@property (nonatomic, readonly, strong) PurchaseInfo * _Nullable purchaseInfo;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



SWIFT_CLASS("_TtC7appmate20SubscriptionDuration")
@interface SubscriptionDuration : NSObject
@end


SWIFT_CLASS("_TtC7appmate23SubscriptionPriceChange")
@interface SubscriptionPriceChange : NSObject
@property (nonatomic, copy) NSString * _Nullable priceChangeDesc;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


enum UserEventType : NSInteger;

SWIFT_CLASS("_TtC7appmate9UserEvent")
@interface UserEvent : NSObject
- (nonnull instancetype)initWithProductId:(NSString * _Nullable)productId userEventType:(enum UserEventType)userEventType OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, UserEventType, open) {
  UserEventTypeAppLaunch = 0,
  UserEventTypeViewProduct = 1,
  UserEventTypePurchaseProduct = 2,
};


/// An object which keeps information about a relation such as master and sub-user info.
SWIFT_CLASS("_TtC7appmate12UserRelation")
@interface UserRelation : NSObject
@property (nonatomic, readonly, copy) NSString * _Nullable masterUser;
@property (nonatomic, readonly, copy) NSString * _Nullable slaveUser;
- (nonnull instancetype)initWithMasterUser:(NSString * _Nullable)masterUser slaveUser:(NSString * _Nullable)slaveUser OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif
